# 多商户电商平台数据库设计文档

## 概述

本文档描述了将单租户电商平台升级为多商户(Multi-Tenant)平台的数据库设计方案。

## 核心设计理念

### 1. 数据隔离策略
采用**共享数据库、共享表结构、通过商户ID隔离数据**的方式（Schema-based Multi-Tenancy）

**优点:**
- 数据库资源利用率高
- 易于维护和升级
- 跨商户数据分析方便
- 成本较低

**关键字段:**
- 所有核心业务表都添加 `merchant_id` 字段
- 通过 `merchant_id = 1` 标识超级商户(平台)
- 普通商户 `merchant_id >= 2`

## 数据库表结构

### 1. 商户表 (merchants)

商户表是多租户架构的核心表，存储所有商户信息。

```sql
CREATE TABLE `merchants` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,

  -- 基础信息
  `merchant_code` VARCHAR(50) UNIQUE NOT NULL COMMENT '商户编码',
  `merchant_name` VARCHAR(100) NOT NULL COMMENT '商户名称',
  `merchant_type` TINYINT DEFAULT 1 COMMENT '1-超级商户，2-普通商户',

  -- 联系信息
  `contact_name` VARCHAR(50),
  `contact_phone` VARCHAR(20),
  `contact_email` VARCHAR(100),
  `address` VARCHAR(255),

  -- 认证信息
  `certification_status` TINYINT DEFAULT 0 COMMENT '0-未认证，1-审核中，2-已认证，3-失败',

  -- 配额限制
  `max_products` INT DEFAULT 1000 COMMENT '最大商品数',
  `max_admins` INT DEFAULT 10 COMMENT '最大管理员数',
  `max_storage` BIGINT DEFAULT 10737418240 COMMENT '最大存储空间(字节)',

  -- 财务信息
  `commission_rate` DECIMAL(5,2) DEFAULT 0.00 COMMENT '平台抽成比例',
  `balance` DECIMAL(12,2) DEFAULT 0.00 COMMENT '账户余额',

  -- 状态
  `status` TINYINT DEFAULT 1 COMMENT '0-禁用，1-启用，2-冻结',
  `expire_time` TIMESTAMP NULL COMMENT '到期时间',

  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB COMMENT='商户表';
```

**商户类型说明:**
- `merchant_type = 1`: 超级商户（平台），拥有最高权限，可管理所有商户
- `merchant_type = 2`: 普通商户，只能管理自己的数据

### 2. 角色表 (roles) - 添加商户关联

```sql
ALTER TABLE `roles`
ADD COLUMN `merchant_id` BIGINT NOT NULL DEFAULT 1 COMMENT '所属商户ID' AFTER id,
ADD CONSTRAINT fk_roles_merchant_id FOREIGN KEY (merchant_id) REFERENCES merchants(id) ON DELETE CASCADE,
ADD INDEX idx_merchant_id (merchant_id);
```

**变更说明:**
- 每个角色现在归属于特定商户
- 商户只能看到和管理自己的角色
- 超级商户可以看到所有角色

### 3. 菜单表 (menus) - 添加商户关联

```sql
ALTER TABLE `menus`
ADD COLUMN `merchant_id` BIGINT NOT NULL DEFAULT 1 COMMENT '所属商户ID' AFTER id,
ADD CONSTRAINT fk_menus_merchant_id FOREIGN KEY (merchant_id) REFERENCES merchants(id) ON DELETE CASCADE,
ADD INDEX idx_merchant_id (merchant_id);
```

**菜单隔离策略:**
- 平台级菜单: `merchant_id = 1`，所有商户可见
- 商户级菜单: `merchant_id = 具体商户ID`，仅该商户可见
- 支持商户自定义菜单结构

### 4. 管理员表 (admins) - 添加商户关联

```sql
ALTER TABLE `admins`
ADD COLUMN `merchant_id` BIGINT NOT NULL DEFAULT 1 COMMENT '所属商户ID' AFTER id,
ADD CONSTRAINT fk_admins_merchant_id FOREIGN KEY (merchant_id) REFERENCES merchants(id) ON DELETE CASCADE,
ADD INDEX idx_merchant_id (merchant_id);
```

**管理员权限范围:**
- 管理员只能管理所属商户的数据
- 超级管理员(`merchant_id = 1`)可管理所有商户

### 5. 商品表 (products) - 添加商户关联

```sql
ALTER TABLE `products`
ADD COLUMN `merchant_id` BIGINT NOT NULL DEFAULT 1 COMMENT '所属商户ID' AFTER id,
ADD CONSTRAINT fk_products_merchant_id FOREIGN KEY (merchant_id) REFERENCES merchants(id),
ADD INDEX idx_merchant_id (merchant_id);
```

### 6. 订单表 (orders) - 添加商户关联

```sql
ALTER TABLE `orders`
ADD COLUMN `merchant_id` BIGINT NOT NULL DEFAULT 1 COMMENT '卖家商户ID' AFTER id,
ADD CONSTRAINT fk_orders_merchant_id FOREIGN KEY (merchant_id) REFERENCES merchants(id),
ADD INDEX idx_merchant_id (merchant_id);
```

**订单设计说明:**
- `merchant_id`: 卖家（商户）ID
- `user_id`: 买家（C端用户）ID
- 支持跨商户订单（用户可购买多个商户的商品）

### 7. 品牌表 (brands) - 添加商户关联

```sql
ALTER TABLE `brands`
ADD COLUMN `merchant_id` BIGINT NOT NULL DEFAULT 1 COMMENT '所属商户ID' AFTER id,
ADD CONSTRAINT fk_brands_merchant_id FOREIGN KEY (merchant_id) REFERENCES merchants(id),
ADD INDEX idx_merchant_id (merchant_id);
```

## 数据关系图

```
商户 (merchants) 1
    ↓
    ├── * 管理员 (admins)
    │       ↓ *
    │       └── * 角色 (roles)
    │               ↓ *
    │               └── * 权限 (permissions)
    │
    ├── * 菜单 (menus)
    │
    ├── * 商品 (products)
    │       ↓ *
    │       └── * 商品SKU (product_skus)
    │
    ├── * 订单 (orders)
    │       ↓ *
    │       └── * 订单明细 (order_items)
    │
    └── * 品牌 (brands)
```

## 超级商户 (平台)

### 创建超级商户

```sql
INSERT INTO `merchants` (
  `id`,
  `merchant_code`,
  `merchant_name`,
  `merchant_type`,
  `description`,
  `certification_status`,
  `status`,
  `expire_time`,
  `max_products`,
  `max_admins`,
  `created_at`
) VALUES (
  1,
  'SUPER_MERCHANT',
  '平台超级商户',
  1,
  '平台超级商户，拥有最高权限',
  2,
  1,
  '2099-12-31 23:59:59',
  999999,
  999,
  NOW()
);
```

### 数据迁移

将现有数据归属到超级商户:

```sql
-- 角色
UPDATE `roles` SET `merchant_id` = 1 WHERE `merchant_id` IS NULL OR `merchant_id` = 0;

-- 菜单
UPDATE `menus` SET `merchant_id` = 1 WHERE `merchant_id` IS NULL OR `merchant_id` = 0;

-- 管理员
UPDATE `admins` SET `merchant_id` = 1 WHERE `merchant_id` IS NULL OR `merchant_id` = 0;

-- 商品
UPDATE `products` SET `merchant_id` = 1 WHERE `merchant_id` IS NULL OR `merchant_id` = 0;

-- 订单
UPDATE `orders` SET `merchant_id` = 1 WHERE `merchant_id` IS NULL OR `merchant_id` = 0;

-- 品牌
UPDATE `brands` SET `merchant_id` = 1 WHERE `merchant_id` IS NULL OR `merchant_id` = 0;
```

## 后端实体(Entity)变更

### 1. Merchant Entity

创建新的商户实体:

```typescript
// backend/src/modules/merchants/entities/merchant.entity.ts
@Entity('merchants')
export class Merchant {
  @PrimaryGeneratedColumn({ type: 'bigint' })
  id: number;

  @Column({ name: 'merchant_code', unique: true })
  merchantCode: string;

  @Column({ name: 'merchant_name' })
  merchantName: string;

  @Column({ name: 'merchant_type', default: 1 })
  merchantType: number;

  // ... 其他字段

  // 关联关系
  @OneToMany(() => Role, role => role.merchant)
  roles: Role[];

  @OneToMany(() => Admin, admin => admin.merchant)
  admins: Admin[];

  @OneToMany(() => Menu, menu => menu.merchant)
  menus: Menu[];
}
```

### 2. Role Entity 更新

```typescript
@Entity('roles')
export class Role {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ name: 'merchant_id', default: 1 })
  merchantId: number;

  // 关联商户
  @ManyToOne(() => Merchant, merchant => merchant.roles)
  @JoinColumn({ name: 'merchant_id' })
  merchant: Merchant;

  // ... 其他字段和关系
}
```

### 3. Admin Entity 更新

```typescript
@Entity('admins')
export class Admin {
  @PrimaryGeneratedColumn({ type: 'bigint' })
  id: number;

  @Column({ name: 'merchant_id', default: 1 })
  merchantId: number;

  // 关联商户
  @ManyToOne(() => Merchant, merchant => merchant.admins)
  @JoinColumn({ name: 'merchant_id' })
  merchant: Merchant;

  // ... 其他字段和关系
}
```

### 4. Menu Entity 更新

```typescript
@Entity('menus')
export class Menu {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ name: 'merchant_id', default: 1 })
  merchantId: number;

  // 关联商户
  @ManyToOne(() => Merchant, merchant => merchant.menus)
  @JoinColumn({ name: 'merchant_id' })
  merchant: Merchant;

  // ... 其他字段和关系
}
```

## 业务逻辑调整

### 1. 数据查询过滤

所有查询必须添加商户ID过滤:

```typescript
// 示例：查询角色
async findRolesByMerchant(merchantId: number) {
  return this.roleRepository.find({
    where: { merchantId },
    relations: ['permissions']
  });
}

// 示例：查询菜单
async findMenusByMerchant(merchantId: number) {
  return this.menuRepository.find({
    where: { merchantId, status: 1 },
    order: { orderNum: 'ASC' }
  });
}
```

### 2. 权限控制

在所有接口中添加商户隔离:

```typescript
// 装饰器：确保只能访问自己商户的数据
@UseGuards(MerchantGuard)
@Controller('roles')
export class RolesController {
  @Get()
  async findAll(@CurrentMerchant() merchantId: number) {
    return this.rolesService.findByMerchant(merchantId);
  }

  @Post()
  async create(
    @CurrentMerchant() merchantId: number,
    @Body() createDto: CreateRoleDto
  ) {
    return this.rolesService.create({
      ...createDto,
      merchantId
    });
  }
}
```

### 3. 超级管理员特权

超级管理员可以跨商户查询:

```typescript
async findAll(adminId: number) {
  const admin = await this.findAdminWithMerchant(adminId);

  // 超级商户可以查看所有
  if (admin.merchant.merchantType === 1) {
    return this.roleRepository.find();
  }

  // 普通商户只能查看自己的
  return this.roleRepository.find({
    where: { merchantId: admin.merchantId }
  });
}
```

## 商户管理功能

### 1. 商户注册/入驻

```typescript
// 商户注册流程
async createMerchant(dto: CreateMerchantDto) {
  // 1. 创建商户
  const merchant = await this.merchantRepository.save({
    merchantCode: this.generateMerchantCode(),
    merchantName: dto.merchantName,
    merchantType: 2, // 普通商户
    certificationStatus: 0, // 待认证
    status: 0, // 待审核
    ...dto
  });

  // 2. 创建默认管理员
  const admin = await this.adminService.create({
    username: dto.adminUsername,
    password: dto.adminPassword,
    merchantId: merchant.id,
    realName: dto.contactName
  });

  // 3. 分配默认角色
  const defaultRole = await this.roleService.createDefaultRole(merchant.id);
  await this.adminService.assignRole(admin.id, defaultRole.id);

  // 4. 创建默认菜单
  await this.menuService.createDefaultMenus(merchant.id);

  return merchant;
}
```

### 2. 商户审核

```typescript
async auditMerchant(merchantId: number, status: number, reason?: string) {
  const merchant = await this.merchantRepository.findOne({
    where: { id: merchantId }
  });

  merchant.certificationStatus = status;
  merchant.certificationTime = new Date();

  if (status === 2) { // 审核通过
    merchant.status = 1; // 启用
    merchant.expireTime = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000); // 1年
  }

  return this.merchantRepository.save(merchant);
}
```

### 3. 商户配额管理

```typescript
async checkQuota(merchantId: number, type: 'products' | 'admins') {
  const merchant = await this.findOne(merchantId);

  if (type === 'products') {
    const productCount = await this.productRepository.count({
      where: { merchantId }
    });
    return productCount < merchant.maxProducts;
  }

  if (type === 'admins') {
    const adminCount = await this.adminRepository.count({
      where: { merchantId }
    });
    return adminCount < merchant.maxAdmins;
  }

  return false;
}
```

## 前端调整

### 1. 商户上下文

在登录后获取并存储商户信息:

```typescript
// stores/merchant.ts
export const useMerchantStore = defineStore('merchant', {
  state: () => ({
    merchantId: null,
    merchantInfo: null,
    isSuperMerchant: false
  }),

  actions: {
    async loadMerchantInfo() {
      const info = await api.getMerchantInfo();
      this.merchantId = info.id;
      this.merchantInfo = info;
      this.isSuperMerchant = info.merchantType === 1;
    }
  }
});
```

### 2. 请求拦截

所有请求自动带上商户ID:

```typescript
// 请求拦截器
axios.interceptors.request.use(config => {
  const merchantStore = useMerchantStore();
  if (merchantStore.merchantId) {
    config.headers['X-Merchant-Id'] = merchantStore.merchantId;
  }
  return config;
});
```

### 3. 菜单渲染

只显示当前商户的菜单:

```typescript
// 获取菜单
async function getMenus() {
  const merchantStore = useMerchantStore();
  const menus = await api.getMenus({
    merchantId: merchantStore.merchantId
  });
  return buildMenuTree(menus);
}
```

## 最佳实践

### 1. 数据隔离原则

- **强制过滤**: 所有数据库查询必须包含 `merchant_id` 过滤条件
- **创建时自动填充**: 创建记录时自动填充当前商户ID
- **删除/更新校验**: 删除和更新前校验数据所属商户

### 2. 性能优化

```sql
-- 复合索引优化
CREATE INDEX idx_products_merchant_status ON products(merchant_id, status);
CREATE INDEX idx_orders_merchant_status ON orders(merchant_id, status);
CREATE INDEX idx_roles_merchant_status ON roles(merchant_id, status);
```

### 3. 安全考虑

- **防止越权访问**: 所有接口验证 `merchantId` 与登录用户的商户ID一致
- **敏感数据加密**: API密钥、密码等敏感信息加密存储
- **审计日志**: 记录跨商户操作日志

### 4. 扩展性设计

- **商户配置**: 使用JSON字段存储灵活配置
- **功能开关**: 通过配置控制不同商户的功能权限
- **主题定制**: 支持商户自定义品牌色、Logo等

## 迁移步骤

1. **备份数据库**
   ```bash
   mysqldump -u root -p wechat_mall > backup_$(date +%Y%m%d).sql
   ```

2. **执行迁移脚本**
   ```bash
   mysql -u root -p wechat_mall < database/migrations/add_multi_tenant_support.sql
   ```

3. **验证数据迁移**
   ```sql
   -- 检查所有表的merchant_id是否正确
   SELECT 'roles', COUNT(*) FROM roles WHERE merchant_id = 1
   UNION ALL
   SELECT 'menus', COUNT(*) FROM menus WHERE merchant_id = 1
   UNION ALL
   SELECT 'admins', COUNT(*) FROM admins WHERE merchant_id = 1;
   ```

4. **更新后端代码**
   - 更新Entity定义
   - 添加商户过滤逻辑
   - 实现商户管理接口

5. **测试**
   - 创建测试商户
   - 验证数据隔离
   - 测试权限控制

## 常见问题

### Q1: 如何处理跨商户共享的数据？

A: 对于需要共享的数据（如公共分类、品牌等），设置 `merchant_id = 1`（平台级），所有商户可见。

### Q2: 如何实现商户数据统计？

A:
```sql
-- 商户数据统计视图
CREATE VIEW merchant_stats AS
SELECT
  m.id,
  m.merchant_name,
  COUNT(DISTINCT p.id) as total_products,
  COUNT(DISTINCT o.id) as total_orders,
  SUM(o.actual_amount) as total_sales
FROM merchants m
LEFT JOIN products p ON m.id = p.merchant_id
LEFT JOIN orders o ON m.id = o.merchant_id
GROUP BY m.id;
```

### Q3: 超级管理员如何管理所有商户？

A: 在业务逻辑中判断 `merchant_type === 1`，跳过 `merchant_id` 过滤。

## 总结

本多商户方案采用共享数据库架构，通过 `merchant_id` 实现数据隔离。关键要点:

1. ✅ 所有核心表都添加 `merchant_id` 外键
2. ✅ 超级商户(`id=1`)作为平台管理方
3. ✅ 所有查询、创建、更新、删除操作都带商户过滤
4. ✅ 后端Entity和Service层统一处理商户隔离
5. ✅ 前端通过商户上下文和请求拦截器保证数据安全

此方案支持:
- 🎯 无限扩展商户数量
- 🎯 灵活的权限控制
- 🎯 完整的数据隔离
- 🎯 高效的跨商户查询（平台级）
- 🎯 商户自定义配置
