# 资源管理多商户支持说明

## 概述

本文档说明如何为资源管理系统（静态资源分类和资源）添加多商户支持。

## 数据库变更

### 1. 资源分类表 (resource_categories)

**添加字段:**
```sql
ALTER TABLE resource_categories
ADD COLUMN merchant_id BIGINT NOT NULL DEFAULT 1 COMMENT '所属商户ID' AFTER id,
ADD CONSTRAINT fk_resource_categories_merchant_id
  FOREIGN KEY (merchant_id) REFERENCES merchants(id) ON DELETE CASCADE,
ADD INDEX idx_merchant_id (merchant_id),
ADD INDEX idx_merchant_parent_status (merchant_id, parent_id, status);
```

**设计说明:**
- 每个资源分类归属于特定商户
- 支持商户自定义分类结构
- 平台级分类（`merchant_id = 1`）可作为公共分类供所有商户使用

### 2. 资源表 (resources)

**添加字段:**
```sql
ALTER TABLE resources
ADD COLUMN merchant_id BIGINT NOT NULL DEFAULT 1 COMMENT '所属商户ID' AFTER id,
ADD CONSTRAINT fk_resources_merchant_id
  FOREIGN KEY (merchant_id) REFERENCES merchants(id) ON DELETE CASCADE,
ADD INDEX idx_merchant_id (merchant_id),
ADD INDEX idx_merchant_category_status (merchant_id, category_id, status);
```

**设计说明:**
- 每个资源归属于特定商户
- 商户只能查看和管理自己的资源
- 资源存储空间受商户配额限制

## Entity 更新

### 1. ResourceCategory Entity

```typescript
@Entity('resource_categories')
export class ResourceCategory {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: 'bigint',
    name: 'merchant_id',
    default: 1,
    comment: '所属商户ID',
  })
  merchantId: number;

  // ... 其他字段

  // 关联商户
  @ManyToOne(() => Merchant, { nullable: false })
  @JoinColumn({ name: 'merchant_id' })
  merchant: Merchant;

  // 关联资源
  @OneToMany(() => Resource, (resource) => resource.category)
  resources: Resource[];
}
```

### 2. Resource Entity

```typescript
@Entity('resources')
export class Resource {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: 'bigint',
    name: 'merchant_id',
    default: 1,
    comment: '所属商户ID',
  })
  merchantId: number;

  // ... 其他字段

  // 关联商户
  @ManyToOne(() => Merchant, { nullable: false })
  @JoinColumn({ name: 'merchant_id' })
  merchant: Merchant;

  // 关联分类
  @ManyToOne(() => ResourceCategory, (category) => category.resources)
  @JoinColumn({ name: 'category_id' })
  category: ResourceCategory;
}
```

### 3. Merchant Entity 扩展

```typescript
@Entity('merchants')
export class Merchant {
  // ... 其他字段

  // 资源相关配额
  @Column({
    type: 'bigint',
    default: 10737418240,
    name: 'max_storage',
    comment: '最大存储空间(字节)，默认10GB',
  })
  maxStorage: number;

  // 关联关系
  @OneToMany(() => Resource, (resource) => resource.merchant)
  resources: Resource[];

  @OneToMany(() => ResourceCategory, (category) => category.merchant)
  resourceCategories: ResourceCategory[];
}
```

## 业务逻辑调整

### 1. 资源分类查询

```typescript
// Service层示例
async findCategoriesByMerchant(merchantId: number) {
  return this.resourceCategoryRepository.find({
    where: {
      merchantId,
      status: 1
    },
    order: {
      sortOrder: 'ASC'
    }
  });
}

// 获取分类树
async getCategoryTree(merchantId: number) {
  const categories = await this.findCategoriesByMerchant(merchantId);
  return this.buildTree(categories);
}
```

### 2. 资源上传

```typescript
async uploadResource(
  merchantId: number,
  file: Express.Multer.File,
  dto: CreateResourceDto
) {
  // 1. 检查存储空间配额
  const canUpload = await this.checkStorageQuota(merchantId, file.size);
  if (!canUpload) {
    throw new BadRequestException('存储空间不足');
  }

  // 2. 上传文件
  const url = await this.uploadToStorage(file);

  // 3. 创建资源记录
  const resource = await this.resourceRepository.save({
    merchantId,
    name: file.originalname,
    url,
    type: this.getResourceType(file.mimetype),
    fileSize: file.size,
    categoryId: dto.categoryId,
    uploaderId: dto.uploaderId,
    uploaderName: dto.uploaderName,
    ...dto
  });

  return resource;
}
```

### 3. 存储空间配额检查

```typescript
async checkStorageQuota(merchantId: number, newFileSize: number): Promise<boolean> {
  // 获取商户信息
  const merchant = await this.merchantRepository.findOne({
    where: { id: merchantId }
  });

  // 计算已使用空间
  const usedStorage = await this.resourceRepository
    .createQueryBuilder('resource')
    .select('SUM(resource.file_size)', 'total')
    .where('resource.merchant_id = :merchantId', { merchantId })
    .andWhere('resource.status = :status', { status: ResourceStatus.ACTIVE })
    .getRawOne();

  const totalUsed = (usedStorage.total || 0) + newFileSize;

  return totalUsed <= merchant.maxStorage;
}

// 获取商户存储空间使用情况
async getStorageUsage(merchantId: number) {
  const merchant = await this.merchantRepository.findOne({
    where: { id: merchantId }
  });

  const stats = await this.resourceRepository
    .createQueryBuilder('resource')
    .select('COUNT(resource.id)', 'count')
    .addSelect('SUM(resource.file_size)', 'used')
    .where('resource.merchant_id = :merchantId', { merchantId })
    .andWhere('resource.status = :status', { status: ResourceStatus.ACTIVE })
    .getRawOne();

  return {
    maxStorage: merchant.maxStorage,
    usedStorage: stats.used || 0,
    availableStorage: merchant.maxStorage - (stats.used || 0),
    usagePercent: ((stats.used || 0) / merchant.maxStorage * 100).toFixed(2),
    resourceCount: stats.count || 0
  };
}
```

### 4. 资源列表查询

```typescript
async findResources(merchantId: number, query: ResourceQueryDto) {
  const qb = this.resourceRepository
    .createQueryBuilder('resource')
    .leftJoinAndSelect('resource.category', 'category')
    .where('resource.merchant_id = :merchantId', { merchantId })
    .andWhere('resource.status != :deleted', { deleted: ResourceStatus.DELETED });

  // 按分类过滤
  if (query.categoryId) {
    qb.andWhere('resource.category_id = :categoryId', {
      categoryId: query.categoryId
    });
  }

  // 按类型过滤
  if (query.type) {
    qb.andWhere('resource.type = :type', { type: query.type });
  }

  // 搜索
  if (query.keyword) {
    qb.andWhere('(resource.name LIKE :keyword OR resource.tags LIKE :keyword)', {
      keyword: `%${query.keyword}%`
    });
  }

  // 排序
  qb.orderBy('resource.created_at', 'DESC');

  // 分页
  const [list, total] = await qb
    .skip((query.page - 1) * query.pageSize)
    .take(query.pageSize)
    .getManyAndCount();

  return {
    list,
    total,
    page: query.page,
    pageSize: query.pageSize
  };
}
```

## 数据库视图

### 1. 商户资源统计视图

```sql
CREATE VIEW merchant_resource_stats AS
SELECT
  m.id AS merchant_id,
  m.merchant_code,
  m.merchant_name,
  COUNT(DISTINCT rc.id) AS total_categories,
  COUNT(DISTINCT r.id) AS total_resources,
  COUNT(DISTINCT CASE WHEN r.type = 'image' THEN r.id END) AS total_images,
  COUNT(DISTINCT CASE WHEN r.type = 'video' THEN r.id END) AS total_videos,
  COALESCE(SUM(r.file_size), 0) AS total_storage_used,
  m.max_storage,
  ROUND(COALESCE(SUM(r.file_size), 0) / m.max_storage * 100, 2) AS storage_usage_percent
FROM merchants m
LEFT JOIN resource_categories rc ON m.id = rc.merchant_id AND rc.status = 1
LEFT JOIN resources r ON m.id = r.merchant_id AND r.status = 1
GROUP BY m.id;
```

**使用示例:**
```sql
-- 查看所有商户的资源使用情况
SELECT * FROM merchant_resource_stats;

-- 查看存储空间使用率超过80%的商户
SELECT * FROM merchant_resource_stats
WHERE storage_usage_percent > 80
ORDER BY storage_usage_percent DESC;
```

### 2. 商户资源分类详情视图

```sql
CREATE VIEW merchant_resource_categories_view AS
SELECT
  rc.id,
  rc.merchant_id,
  m.merchant_name,
  rc.name AS category_name,
  rc.parent_id,
  parent.name AS parent_name,
  rc.level,
  rc.sort_order,
  rc.status,
  COUNT(DISTINCT r.id) AS resource_count,
  COALESCE(SUM(r.file_size), 0) AS total_size,
  rc.created_at,
  rc.updated_at
FROM resource_categories rc
INNER JOIN merchants m ON rc.merchant_id = m.id
LEFT JOIN resource_categories parent ON rc.parent_id = parent.id
LEFT JOIN resources r ON rc.id = r.category_id AND r.status = 1
GROUP BY rc.id;
```

**使用示例:**
```sql
-- 查看某商户的所有分类及其资源数
SELECT * FROM merchant_resource_categories_view
WHERE merchant_id = 1
ORDER BY sort_order;
```

## Controller 层示例

```typescript
@Controller('resources')
@UseGuards(JwtAuthGuard, MerchantGuard)
export class ResourceController {
  constructor(private readonly resourceService: ResourceService) {}

  @Get('categories')
  async getCategories(@CurrentMerchant() merchantId: number) {
    return this.resourceService.getCategoryTree(merchantId);
  }

  @Post('upload')
  @UseInterceptors(FileInterceptor('file'))
  async upload(
    @CurrentMerchant() merchantId: number,
    @CurrentUser() user: any,
    @UploadedFile() file: Express.Multer.File,
    @Body() dto: CreateResourceDto
  ) {
    return this.resourceService.uploadResource(merchantId, file, {
      ...dto,
      uploaderId: user.id,
      uploaderName: user.realName || user.username
    });
  }

  @Get('list')
  async getResources(
    @CurrentMerchant() merchantId: number,
    @Query() query: ResourceQueryDto
  ) {
    return this.resourceService.findResources(merchantId, query);
  }

  @Get('storage-usage')
  async getStorageUsage(@CurrentMerchant() merchantId: number) {
    return this.resourceService.getStorageUsage(merchantId);
  }

  @Delete(':id')
  async deleteResource(
    @CurrentMerchant() merchantId: number,
    @Param('id') id: number
  ) {
    // 验证资源所属商户
    const resource = await this.resourceService.findOne(id);
    if (resource.merchantId !== merchantId) {
      throw new ForbiddenException('无权删除此资源');
    }
    return this.resourceService.delete(id);
  }
}
```

## 前端调整

### 1. 资源管理页面

```typescript
// stores/resource.ts
export const useResourceStore = defineStore('resource', {
  state: () => ({
    categories: [],
    resources: [],
    storageUsage: null
  }),

  actions: {
    async loadCategories() {
      const merchantStore = useMerchantStore();
      this.categories = await api.getResourceCategories({
        merchantId: merchantStore.merchantId
      });
    },

    async loadStorageUsage() {
      this.storageUsage = await api.getStorageUsage();
    },

    async uploadFile(file: File, categoryId: number) {
      // 检查存储空间
      if (this.storageUsage) {
        const availableSpace = this.storageUsage.availableStorage;
        if (file.size > availableSpace) {
          throw new Error('存储空间不足');
        }
      }

      const formData = new FormData();
      formData.append('file', file);
      formData.append('categoryId', categoryId.toString());

      return api.uploadResource(formData);
    }
  }
});
```

### 2. 存储空间提示组件

```vue
<template>
  <div class="storage-usage">
    <div class="usage-bar">
      <div
        class="used"
        :style="{ width: `${usagePercent}%` }"
        :class="{ warning: usagePercent > 80, danger: usagePercent > 95 }"
      ></div>
    </div>
    <div class="usage-text">
      已使用: {{ formatSize(used) }} / {{ formatSize(total) }} ({{ usagePercent }}%)
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps<{
  used: number;
  total: number;
}>();

const usagePercent = computed(() =>
  ((props.used / props.total) * 100).toFixed(1)
);

function formatSize(bytes: number) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
  if (bytes < 1024 * 1024 * 1024) return (bytes / 1024 / 1024).toFixed(2) + ' MB';
  return (bytes / 1024 / 1024 / 1024).toFixed(2) + ' GB';
}
</script>
```

## 安全考虑

### 1. 数据隔离

```typescript
// 中间件：确保商户只能访问自己的资源
@Injectable()
export class ResourceOwnershipGuard implements CanActivate {
  constructor(private readonly resourceService: ResourceService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const merchantId = request.user.merchantId;
    const resourceId = request.params.id;

    const resource = await this.resourceService.findOne(resourceId);

    if (resource.merchantId !== merchantId) {
      throw new ForbiddenException('无权访问此资源');
    }

    return true;
  }
}
```

### 2. 文件存储隔离

建议按商户ID组织存储目录:

```
/storage/
  ├── merchants/
  │   ├── 1/           # 超级商户
  │   │   ├── images/
  │   │   └── videos/
  │   ├── 2/           # 商户2
  │   │   ├── images/
  │   │   └── videos/
  │   └── 3/           # 商户3
  │       ├── images/
  │       └── videos/
```

```typescript
function getStoragePath(merchantId: number, type: ResourceType): string {
  return `storage/merchants/${merchantId}/${type}s/`;
}
```

## 配额管理

### 1. 商户套餐配置

```typescript
// 套餐配置示例
const MERCHANT_PLANS = {
  basic: {
    name: '基础版',
    maxStorage: 10 * 1024 * 1024 * 1024, // 10GB
    maxProducts: 100,
    maxAdmins: 3,
    price: 99
  },
  pro: {
    name: '专业版',
    maxStorage: 50 * 1024 * 1024 * 1024, // 50GB
    maxProducts: 1000,
    maxAdmins: 10,
    price: 299
  },
  enterprise: {
    name: '企业版',
    maxStorage: 200 * 1024 * 1024 * 1024, // 200GB
    maxProducts: 10000,
    maxAdmins: 50,
    price: 999
  }
};
```

### 2. 配额监控

```typescript
// 定时任务：检查配额使用情况
@Cron('0 0 * * *') // 每天凌晨执行
async checkQuotaUsage() {
  const merchants = await this.merchantRepository.find({
    where: { status: 1 }
  });

  for (const merchant of merchants) {
    const usage = await this.resourceService.getStorageUsage(merchant.id);

    // 存储空间超过90%，发送预警
    if (usage.usagePercent > 90) {
      await this.notificationService.send({
        merchantId: merchant.id,
        type: 'quota_warning',
        title: '存储空间预警',
        message: `您的存储空间使用率已达${usage.usagePercent}%，请及时清理或升级套餐`
      });
    }
  }
}
```

## 迁移步骤

### 1. 执行SQL迁移

```bash
mysql -u root -p wechat_mall < database/migrations/add_merchant_to_resources.sql
```

### 2. 验证数据

```sql
-- 检查字段是否添加成功
DESCRIBE resource_categories;
DESCRIBE resources;

-- 检查数据迁移
SELECT merchant_id, COUNT(*) FROM resource_categories GROUP BY merchant_id;
SELECT merchant_id, COUNT(*) FROM resources GROUP BY merchant_id;

-- 查看视图
SELECT * FROM merchant_resource_stats WHERE merchant_id = 1;
```

### 3. 更新代码

1. 更新Entity定义
2. 更新Service层查询逻辑
3. 添加商户过滤中间件
4. 添加配额检查逻辑
5. 更新前端资源管理页面

### 4. 测试

- ✅ 创建测试商户
- ✅ 上传资源并验证商户隔离
- ✅ 测试存储空间配额限制
- ✅ 验证跨商户访问被拦截
- ✅ 测试资源查询过滤

## 常见问题

### Q1: 如何处理跨商户共享的公共资源？

A: 创建平台级公共资源分类（`merchant_id = 1`），商户可以引用但不能修改。

```typescript
async getAvailableCategories(merchantId: number) {
  return this.resourceCategoryRepository.find({
    where: [
      { merchantId }, // 商户自己的分类
      { merchantId: 1 } // 平台公共分类
    ],
    order: { sortOrder: 'ASC' }
  });
}
```

### Q2: 商户删除后，其资源如何处理？

A: 通过外键的 `ON DELETE CASCADE` 约束自动删除相关资源。也可以实现软删除：

```typescript
async deleteMerchant(merchantId: number) {
  // 先标记资源为已删除
  await this.resourceRepository.update(
    { merchantId },
    { status: ResourceStatus.DELETED }
  );

  // 再删除商户
  await this.merchantRepository.delete(merchantId);
}
```

### Q3: 如何实现资源回收站？

A: 使用软删除状态：

```typescript
async softDeleteResource(id: number) {
  return this.resourceRepository.update(id, {
    status: ResourceStatus.DELETED
  });
}

async restoreResource(id: number) {
  return this.resourceRepository.update(id, {
    status: ResourceStatus.ACTIVE
  });
}

// 定时清理回收站（30天前的）
@Cron('0 2 * * *')
async cleanTrash() {
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);

  await this.resourceRepository
    .createQueryBuilder()
    .delete()
    .where('status = :deleted', { deleted: ResourceStatus.DELETED })
    .andWhere('updated_at < :date', { date: thirtyDaysAgo })
    .execute();
}
```

## 总结

资源管理系统的多商户支持包括：

1. ✅ 数据库添加 `merchant_id` 字段和约束
2. ✅ Entity更新商户关联关系
3. ✅ 业务逻辑添加商户过滤
4. ✅ 实现存储空间配额管理
5. ✅ 创建统计视图便于监控
6. ✅ 前端适配商户上下文
7. ✅ 安全隔离和权限控制

完成这些更改后，资源管理系统将完全支持多商户隔离和配额管理。
